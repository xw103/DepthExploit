package org.exploit.depth.utils;

import android.app.ProgressDialog;
import android.content.Context;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageManager;
import android.os.Bundle;
import android.util.Log;

import org.exploit.depth.internal.RootServer;

import java.io.ByteArrayOutputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

public class RootUtils {

    private static Shell.Interactive shell;

    public static List<String> getLaunchScript(Context context, Class mainClass, String[] params, String[] libs) {
        List<String> paramList = new ArrayList<String>();
        paramList.add(context.getPackageCodePath());
        if (libs != null) {
            for (String lib : libs) {
                paramList.add(RootServer.getLibraryPath(context, lib));
            }
        }
        if (params != null) {
            Collections.addAll(paramList, params);
        }
        return RootServer.getLaunchScript(context, mainClass, null, null, paramList.toArray(new String[0]), context.getPackageName() + ":root");
    }

    public static void createSUProcess(Context context, Class mainClass, String[] params, String[] libs, IPCUtils.OnLine ol) {
        int len = params == null ? 0 : params.length;
        String[] newParams = new String[+2];
        newParams[0] = getMetaDataStringApplication(context, "RootMain", null);
        newParams[1] = context.getPackageName();
        if (newParams[0] == null) {
            throw new NullPointerException("RootMain:Null.");
        }
        try {
            boolean isFind = false;
            for (Class<?> i : Class.forName(newParams[0]).getInterfaces()) {
                if (i.getName().contains("IRootRemote")) {
                    isFind = true;
                }
            }
            if (!isFind) {
                throw new NullPointerException("RootMain:在指向的类中找不到接口# IRootRemote");
            }
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
            throw new NullPointerException("RootMain:找不到类#" + newParams[0]);
        }
        for (int i = 0; i < len; i++) {
            newParams[i + 2] = params[i];
        }
        List<String> script = getLaunchScript(context, mainClass, newParams, libs);
        if ((shell == null) || !shell.isRunning()) {
            shell = (new Shell.Builder())
                    .useSU()
                    .open(new Shell.OnCommandResultListener() {
                        @Override
                        public void onCommandResult(int commandCode, int exitCode, List<String> output) {
                            if (exitCode != SHELL_RUNNING) {
                                //执行中
                            }
                        }
                    });
        }

        // 异步运行Script
        shell.addCommand(script, 0, new Shell.OnCommandLineListener() {
            @Override
            public void onCommandResult(int commandCode, int exitCode) {
                //执行完成
            }

            @Override
            public void onLine(String line) {
                // 接收输出
                if (ol != null)
                    ol.onLine(line);
            }
        });
    }

    private static String getMetaDataStringApplication(Context context, String key, String defValue) {
        Bundle bundle = getAppMetaDataBundle(context.getPackageManager(), context.getPackageName());
        if (bundle != null && bundle.containsKey(key)) {
            return bundle.getString(key);
        }
        return defValue;
    }

    private static Bundle getAppMetaDataBundle(PackageManager packageManager,
                                               String packageName) {
        Bundle bundle = null;
        try {
            ApplicationInfo ai = packageManager.getApplicationInfo(packageName,
                    PackageManager.GET_META_DATA);
            bundle = ai.metaData;
        } catch (PackageManager.NameNotFoundException e) {
            Log.e("getMetaDataBundle", e.getMessage(), e);
        }
        return bundle;
    }

    public static boolean installHookFrame(Context context) {
        String name = "depth";
        String base_apk = context.getApplicationInfo().sourceDir;
        try {
            ZipFile zip = new ZipFile(base_apk);
            ZipEntry ze_32 = zip.getEntry("lib/armeabi-v7a/lib" + name + ".so");
            ZipEntry ze_64 = zip.getEntry("lib/arm64-v8a/lib" + name + ".so");
            InputStream is_32 = zip.getInputStream(ze_32);
            InputStream is_64 = zip.getInputStream(ze_64);
            byte[] buf_32 = new byte[(int) ze_32.getSize()];
            byte[] buf_64 = new byte[(int) ze_64.getSize()];
            is_32.read(buf_32);
            is_64.read(buf_64);
            FileOutputStream fos_32 = new FileOutputStream(context.getFilesDir() + "/lib" + name + ".x32");
            fos_32.write(buf_32);
            fos_32.close();
            is_32.close();
            buf_32 = null;
            FileOutputStream fos_64 = new FileOutputStream(context.getFilesDir() + "/lib" + name + ".x64");
            fos_64.write(buf_64);
            fos_64.close();
            is_64.close();
            buf_64 = null;
            zip.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
        StringBuffer sb = new StringBuffer();
        sb.append("cp " + context.getFilesDir() + "/lib" + name + ".x32 /system/lib/lib" + name + ".so");
        sb.append("\n");
        sb.append("chmod 644 /system/lib/lib" + name + ".so");
        sb.append("\n");
        sb.append("rm -f " + context.getFilesDir() + "/lib" + name + ".x32");
        sb.append("\n");
        sb.append("cp " + context.getFilesDir() + "/lib" + name + ".x64 /system/lib64/lib" + name + ".so");
        sb.append("\n");
        sb.append("chmod 644 /system/lib64/lib" + name + ".so");
        sb.append("\n");
        sb.append("rm -f " + context.getFilesDir() + "/lib" + name + ".x64");
        sb.append("\n");
        sb.append("dir=\"/system/depth/\"\n");
        sb.append("if [ ! -d \"$dir\" ];then\n");
        sb.append("mkdir $dir\nfi");
        sb.append("\n");
        sb.append("chmod 755 $dir");
        sb.append("\n");
        sb.append("dir1=\"/system/depth/lib/\"\n");
        sb.append("if [ ! -d \"$dir1\" ];then\n");
        sb.append("mkdir $dir1\nfi");
        sb.append("\n");
        sb.append("chmod 755 $dir1");
        sb.append("\n");
        sb.append("dir2=\"/system/depth/lib64/\"\n");
        sb.append("if [ ! -d \"$dir2\" ];then\n");
        sb.append("mkdir $dir2\nfi");
        sb.append("\n");
        sb.append("chmod 755 $dir2");
        sb.append("\n");
        sb.append("dir3=\"/system/depth/etc/\"\n");
        sb.append("if [ ! -d \"$dir3\" ];then\n");
        sb.append("mkdir $dir3\nfi");
        sb.append("\n");
        sb.append("chmod 755 $dir3");
        sb.append("\n");
        sb.append("file=\"/system/depth/etc/packages.name.txt\"\n");
        sb.append("if [ ! -f \"$file\" ];then\n");
        sb.append("touch $file\nfi");
        sb.append("\n");
        sb.append("chmod 644 $file");
        runShell(sb.toString(), true);
        return false;
    }

    public static byte[] runShell(String command, boolean isRoot) {
//        System.out.println("cmd:"+command);
        try {
            Process process = Runtime.getRuntime().exec(isRoot ? "su" : "sh");
            InputStream ins = process.getInputStream();
            InputStream es = process.getErrorStream();
            OutputStream ous = process.getOutputStream();
            ous.write("\n".getBytes());
            ous.flush();
            ous.write(command.getBytes());
            ous.flush();
            ous.write("\n".getBytes());
            ous.flush();
            ous.write("exit".getBytes());
            ous.flush();
            ous.write("\n".getBytes());
            ous.flush();
            byte[] result = readInputStream(ins, false);
            byte[] error = readInputStream(es, false);
            process.waitFor();
            ins.close();
            es.close();
            ous.close();
            if (new String(error).trim().isEmpty()) {
                return result;
            } else {
                return null;
            }
        } catch (Throwable th) {
            return null;
        }
    }

    public static byte[] readInputStream(InputStream ins, boolean close) {
        try {
            ByteArrayOutputStream bos = new ByteArrayOutputStream();
            int i = -1;
            byte[] buf = new byte[1024];
            while ((i = ins.read(buf)) != -1) {
                bos.write(buf, 0, i);
            }
            if (close) {
                ins.close();
                bos.close();
            }
            return bos.toByteArray();
        } catch (Throwable th) {
            return Log.getStackTraceString(th).getBytes();
        }
    }
}
